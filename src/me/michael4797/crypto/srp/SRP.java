package me.michael4797.crypto.srp;

import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

/**
 * Implements the common operations used by both the {@link SRPServer} and {@link SRPUser}
 */
class SRP {
	
	private static final SecureRandom random = new SecureRandom();
	static final BigInteger g = new BigInteger("2"); //Generator
	static final BigInteger N = new BigInteger("AC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4"+
													   "A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF60"+
													   "95179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF"+
													   "747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B907"+
													   "8717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB37861"+
													   "60279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DB"+
													   "FBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73", 16); //Large prime
	static final BigInteger k = fromByteArray(hash(padToN(N), padToN(g))); //Multiplier

	/**
	 * Pads the specified array to the specified length by prepending the
	 * array with 0's.
	 * @param n The array to be padded.
	 * @param len The desired length of the array.
	 * @return A new array, padded to the specified length.
	 */
	static byte[] padTo(byte[] n, int len) {

		int padding = len - n.length;
		if(padding < 0)
			throw new IllegalArgumentException("len must be greater than or equal to the length of n.");
		
		byte[] result = new byte[len];
		  
		int i = padding;
		for(byte b: n)
			result[i++] = b;
		  
		return result;
	}

	/**
	 * Converts the specified BigInteger to a byte array, then pads it to the length of N.
	 * @param number The BigInteger to be converted and padded.
	 * @return A new byte array that represents the specified BigInteger and is the same length as N.
	 */
	static byte[] padToN(BigInteger number) {
				
		return padTo(toByteArray(number), 256);
	}
		
	/**
	 * Converts and OpenSSL compliant byte array representation of a BigInteger into a
	 * java BigInteger.
	 * @param bytes The byte array to be converted.
	 * @return The BigInteger representation of the specified array.
	 */
	static BigInteger fromByteArray(byte[] bytes){
		
		byte[] b = bytes;
		if(b[0] < 0){
		
			b = new byte[bytes.length+1];
			for(int i = 0; i < bytes.length; i++)
				b[i+1] = bytes[i];
		}
		
		return new BigInteger(b);
	}
	
	/**
	 * Converts the specified BigInteger into a byte array in a way that can be interpreted by any
	 * OpenSSL compliant application.
	 * @param b The BigInteger to convert.
	 * @return The OpenSSL compliant byte array representation of the specified BigInteger.
	 */
	static byte[] toByteArray(BigInteger b){
		
		byte[] bytes = b.toByteArray();
		if(bytes[0] < 0)
			bytes = b.negate().toByteArray();
		
		if(bytes[0] == 0){
			
			byte[] tmp = new byte[bytes.length-1];
			for(int i = 0; i < tmp.length; i++)
				tmp[i] = bytes[i+1];
			
			bytes = tmp;			
		}
		
		return bytes;
	}
	
	/**
	 * Generates the specified number of bytes from a secure random number generator. 
	 * @param bytes The number of bytes to be generated.
	 * @return The generated bytes.
	 * @see SecureRandom
	 */
	public static byte[] randomBytes(int bytes){
		
		byte[] data = new byte[bytes];
		random.nextBytes(data);
		return data;
	}
	
	/**
	 * Converts a String into a byte array, one char per byte, so that it may be hashed.
	 * @param string The string to convert.
	 * @return The byte array representation of the String.
	 */
	static byte[] toByteArray(String string){
		
		byte[] array = new byte[string.length()];
		for(int i = 0; i < array.length; i++)
			array[i] = (byte)(string.charAt(i)&255);
		return array;
	}
	
	/**
	 * Calculates the proof of session key value from the identifier, salt, ephemeral, and
	 * session key values.
	 * @param I The identifier.
	 * @param s The salt.
	 * @param A The client ephemeral.
	 * @param B The server ephemeral.
	 * @param K The session key.
	 * @return The proof of session key.
	 */
	static byte[] getM(String I, byte[] s, byte[] A, byte[] B, byte[] K){
		
		byte[] hN = hash(toByteArray(N));
		byte[] hG = hash(toByteArray(g));
		byte[] hI = hash(toByteArray(I));
		byte[] hX = new byte[hN.length];
		for(int i = 0; i < hX.length; i++)
			hX[i] = (byte) (hN[i]^hG[i]);
		
		return hash(hX, hI, s, A, B, K);
	}
	
	/**
	 * Calculates the random scrambling parameter from the given ephemeral values.
	 * @param A The client ephemeral.
	 * @param B The server ephemeral.
	 * @return The random scrambling parameter.
	 */
	static BigInteger getU(byte[] A, byte[] B){
		
	    byte[] uBytes = new byte[512];
	    
	    int offset = 256-A.length;
	    for(int i = 0; i < A.length; i++)
	    	uBytes[i+offset] = A[i];
	    
	    offset = 512-B.length;
	    for(int i = 0; i < B.length; i++)
	    	uBytes[i+offset] = B[i];
	    
	    byte[] hash = hash(uBytes);
	    return fromByteArray(hash);
	}
	
	/**
	 * Hashes the specified byte arrays using SHA-256 and returns the result.
	 * @param updates The data to be hashed.
	 * @return The digested hash.
	 */
	static byte[] hash(byte[]... updates){
		
		try {
			
			MessageDigest md = MessageDigest.getInstance("SHA-256");
			for(int i = 0; i < updates.length; i++)
				md.update(updates[i]);
			
			return md.digest();
		} catch (NoSuchAlgorithmException e) {

			throw new RuntimeException(e);
		}
	}
}
